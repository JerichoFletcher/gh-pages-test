var ot=e=>{throw TypeError(e)};var at=(e,t,r)=>t.has(e)||ot("Cannot "+r);var n=(e,t,r)=>(at(e,t,"read from private field"),r?r.call(e):t.get(e)),c=(e,t,r)=>t.has(e)?ot("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,r),a=(e,t,r,s)=>(at(e,t,"write to private field"),s?s.call(e,r):t.set(e,r),r);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const h of o.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&s(h)}).observe(document,{childList:!0,subtree:!0});function r(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerPolicy&&(o.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?o.credentials="include":i.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(i){if(i.ep)return;i.ep=!0;const o=r(i);fetch(i.href,o)}})();var lt=`#version 100
precision mediump float;

attribute vec2 a_position;
attribute vec3 a_color;
varying vec3 v_color;

uniform mat4 u_world;
uniform mat4 u_mv;
uniform mat4 u_proj;

void main(){
  v_color = a_color;
  gl_Position = u_proj * u_mv * u_world * vec4(a_position, 0.0, 1.0);
}`,dt=`#version 100
precision mediump float;

varying vec3 v_color;
uniform float u_time;

void main(){
  vec3 rolledColor = fract(v_color + vec3(u_time));
  gl_FragColor = vec4(rolledColor, 1.0);
}`;const H="OES_vertex_array_object",z="ANGLE_instanced_arrays";var S=(e=>(e[e.WebGL1=0]="WebGL1",e[e.WebGL2=1]="WebGL2",e))(S||{}),I,m;class ut{constructor(t){c(this,I);c(this,m);a(this,I,t),a(this,m,new Map),t.version===0?(this.setExtension(H,this.retrieveExtension(t.gl,H)),this.setExtension(z,this.retrieveExtension(t.gl,z))):(this.setExtension(H,t.gl),this.setExtension(z,t.gl))}retrieveExtension(t,r){const s=t.getExtension(r);if(!s)return null;const i=r.split("_",1)[0],o=Object.getPrototypeOf(s),h=Object.fromEntries(Object.entries(o).map(([u,d])=>[u.replace(new RegExp(`_?${i}$`,"i"),""),typeof d=="function"?this.callWithContext(s,d):d]));return h.isExtension=!0,h}callWithContext(t,r){return(...s)=>r.call(t,...s)}getExtension(t){if(!n(this,m).has(t))throw new Error(`Missing WebGL extension: ${t}`);return n(this,m).get(t)}setExtension(t,r){r?n(this,m).set(t,r):n(this,m).delete(t)}get context(){return n(this,I)}get loadedExtensions(){return new Map([...n(this,m).entries()].filter(([t,r])=>r.isExtension))}get vertexArray(){return this.getExtension(H)}get instancedArrays(){return this.getExtension(z)}}I=new WeakMap,m=new WeakMap;var U,V;const C=class C{constructor(t){c(this,U);c(this,V);a(this,U,t),a(this,V,new ut(t))}static latest(t){const r=t.getContext("webgl2");if(r)return new C({version:S.WebGL2,gl:r});const s=t.getContext("webgl");if(s)return new C({version:S.WebGL1,gl:s});throw new Error("Failed to create WebGL wrapper: WebGL not supported")}static ofVersion(t,r){let s;switch(r){case S.WebGL1:s=t.getContext("webgl");break;case S.WebGL2:s=t.getContext("webgl2");break}if(!s)throw new Error("Failed to create WebGL wrapper: Version not supported");return new C({version:r,gl:s})}get context(){return n(this,U)}get ext(){return n(this,V)}};U=new WeakMap,V=new WeakMap;let K=C;var F,$,R;const Y=class Y{constructor(t,r,s){c(this,F);c(this,$);c(this,R);a(this,F,t),a(this,$,r),a(this,R,s)}static validBeforeDisposed(t,r){return new Y(t,0,r)}static validAfterDisposed(t,r){return new Y(t,1,r)}executeWhenValid(t){switch(n(this,$)){case 0:if(n(this,F).isDisposed)throw new Error("Invalid state: Already disposed");return t();case 1:if(!n(this,F).isDisposed)throw new Error("Invalid state: Not disposed");return t()}}get value(){return this.executeWhenValid(()=>n(this,R))}set value(t){this.executeWhenValid(()=>a(this,R,t))}};F=new WeakMap,$=new WeakMap,R=new WeakMap;let O=Y;var X=(e=>(e[e.Vertex=0]="Vertex",e[e.Fragment=1]="Fragment",e))(X||{}),b,M,B,P;const et=class et{constructor(t,r,s){c(this,b);c(this,M);c(this,B);c(this,P);a(this,M,t),a(this,B,r);const i=t.context.gl,o=i.createShader(r===0?i.VERTEX_SHADER:i.FRAGMENT_SHADER);if(!o){const h=i.getError();throw new Error(`Failed to create shader (error code ${h})`)}if(i.shaderSource(o,s),i.compileShader(o),!i.getShaderParameter(o,i.COMPILE_STATUS)){const h=i.getError(),u=i.getShaderInfoLog(o);throw i.deleteShader(o),new Error(`Failed to compile shader (error code: ${h}): ${u}`)}a(this,P,O.validBeforeDisposed(this,o)),a(this,b,!1)}static create(t,r,s){return new et(t,r,s)}get contextWrapper(){return n(this,M)}get type(){return n(this,B)}get shader(){return n(this,P).value}get isDisposed(){return n(this,b)}dispose(){n(this,b)||(n(this,M).context.gl.deleteShader(n(this,P).value),a(this,b,!0))}};b=new WeakMap,M=new WeakMap,B=new WeakMap,P=new WeakMap;let j=et;var w,f,x,W,D,p,T;const rt=class rt{constructor(t,r,s){c(this,w);c(this,f);c(this,x);c(this,W);c(this,D);c(this,p);c(this,T);a(this,f,t);const i=t.context.gl,o=i.createProgram();if(!o){const d=i.getError();throw new Error(`Failed to create program (error code ${d})`)}if(i.attachShader(o,r.shader),i.attachShader(o,s.shader),i.linkProgram(o),!i.getProgramParameter(o,i.LINK_STATUS)){const d=i.getError(),l=i.getProgramInfoLog(o);throw i.deleteProgram(o),new Error(`Failed to link program (error code: ${d}): ${l}`)}a(this,p,new Map),a(this,T,new Map);const h=i.getProgramParameter(o,i.ACTIVE_UNIFORMS);for(let d=0;d<h;d++){const l=i.getActiveUniform(o,d),L=i.getUniformLocation(o,l.name);n(this,p).set(l.name,{name:l.name,size:l.size,type:l.type,location:L})}const u=i.getProgramParameter(o,i.ACTIVE_ATTRIBUTES);for(let d=0;d<u;d++){const l=i.getActiveAttrib(o,d),L=i.getAttribLocation(o,l.name);n(this,T).set(l.name,{name:l.name,size:l.size,type:l.type,location:L})}a(this,x,O.validBeforeDisposed(this,o)),a(this,W,r),a(this,D,s),a(this,w,!1)}static create(t,r,s){return new rt(t,r,s)}use(){n(this,f).context.gl.useProgram(n(this,x).value)}setUniform(t,r){const s=n(this,f).context.gl,i=n(this,p).get(t);if(!i)throw new Error(`Unknown uniform: ${t}`);if(typeof r=="number")s.uniform1f(i.location,r);else if(Array.isArray(r)||r instanceof Float32Array)switch(r.length){case 2:s.uniform2fv(i.location,r);break;case 3:s.uniform3fv(i.location,r);break;case 4:s.uniform4fv(i.location,r);break;default:throw new Error(`Unsupported uniform array size: ${r.length}`)}}setUniformMatrix(t,r){const s=n(this,f).context.gl,i=n(this,p).get(t);if(!i)throw new Error(`Unknown uniform: ${t}`);switch(r.length){case 4:s.uniformMatrix2fv(i.location,!1,r);break;case 9:s.uniformMatrix3fv(i.location,!1,r);break;case 16:s.uniformMatrix4fv(i.location,!1,r);break;default:throw new Error(`Unsupported uniform matrix size: ${r.length}`)}}get contextWrapper(){return n(this,f)}get program(){return n(this,x).value}get vertexShader(){return n(this,W)}get fragmentShader(){return n(this,D)}get uniforms(){return n(this,p)}get attributes(){return n(this,T)}get isDisposed(){return n(this,w)}dispose(){n(this,w)||(n(this,f).context.gl.detachShader(n(this,x),n(this,W).shader),n(this,f).context.gl.detachShader(n(this,x),n(this,D).shader),n(this,f).context.gl.deleteProgram(n(this,x)),a(this,w,!0))}};w=new WeakMap,f=new WeakMap,x=new WeakMap,W=new WeakMap,D=new WeakMap,p=new WeakMap,T=new WeakMap;let J=rt;var Q=(e=>(e[e.Array=0]="Array",e[e.Element=1]="Element",e))(Q||{}),Z=(e=>(e[e.Static=0]="Static",e[e.Dynamic=1]="Dynamic",e[e.Stream=2]="Stream",e))(Z||{}),v,g,N,G,A;const it=class it{constructor(t,r,s){c(this,v);c(this,g);c(this,N);c(this,G);c(this,A);a(this,g,t),a(this,N,r),a(this,G,s);const i=t.context.gl.createBuffer();if(!i){const o=t.context.gl.getError();throw new Error(`Failed to create buffer object (error code: ${o})`)}a(this,A,O.validBeforeDisposed(this,i)),a(this,v,!1)}static create(t,r,s){return new it(t,r,s)}get target(){switch(n(this,N)){case 0:return n(this,g).context.gl.ARRAY_BUFFER;case 1:return n(this,g).context.gl.ELEMENT_ARRAY_BUFFER}}get usage(){switch(n(this,G)){case 0:return n(this,g).context.gl.STATIC_DRAW;case 1:return n(this,g).context.gl.DYNAMIC_DRAW;case 2:return n(this,g).context.gl.STREAM_DRAW}}bind(){const t=n(this,A).value;n(this,g).context.gl.bindBuffer(this.target,t)}unbind(){n(this,g).context.gl.bindBuffer(this.target,null)}setData(t){this.bind(),n(this,g).context.gl.bufferData(this.target,t,this.usage),this.unbind()}get contextWrapper(){return n(this,g)}get type(){return n(this,N)}get buffer(){return n(this,A).value}get isDisposed(){return n(this,v)}dispose(){n(this,v)||(n(this,g).context.gl.deleteBuffer(n(this,A)),a(this,v,!0))}};v=new WeakMap,g=new WeakMap,N=new WeakMap,G=new WeakMap,A=new WeakMap;let k=it;var y,E,_;const nt=class nt{constructor(t){c(this,y);c(this,E);c(this,_);a(this,E,t);const r=t.ext.vertexArray.createVertexArray();if(!r){const s=t.context.gl.getError();throw new Error(`Failed to create VAO (error code ${s})`)}a(this,_,O.validBeforeDisposed(this,r)),a(this,y,!1)}static create(t){return new nt(t)}bind(){n(this,E).ext.vertexArray.bindVertexArray(n(this,_).value)}unbind(){n(this,E).ext.vertexArray.bindVertexArray(null)}setAttribute(t,r,s,i,o,h){this.bind(),r.bind();const u=n(this,E).context.gl;u.enableVertexAttribArray(t),u.vertexAttribPointer(t,s,i,!1,o,h),r.unbind(),this.unbind()}bindElementBuffer(t){this.bind(),t.bind(),this.unbind()}get contextWrapper(){return n(this,E)}get vao(){return n(this,_).value}get isDisposed(){return n(this,y)}dispose(){n(this,y)||(n(this,E).ext.vertexArray.deleteVertexArray(n(this,_).value),a(this,y,!0))}};y=new WeakMap,E=new WeakMap,_=new WeakMap;let tt=nt;var ct=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});function q(){var e=new ct(16);return ct!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function gt(e,t,r,s,i,o,h){var u=1/(t-r),d=1/(s-i),l=1/(o-h);return e[0]=-2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*d,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*l,e[11]=0,e[12]=(t+r)*u,e[13]=(i+s)*d,e[14]=(h+o)*l,e[15]=1,e}var ft=gt;function mt(e){const t=K.ofVersion(e,S.WebGL1),r=t.context.gl,s=()=>{let i=!1;const o=e.clientWidth,h=e.clientHeight;(e.width!==o||e.height!==h)&&(e.width=o,e.height=h,i=!0),i&&r.viewport(0,0,e.width,e.height)};return window.addEventListener("resize",s),s(),console.log("Loaded WebGL version:",r.getParameter(r.VERSION)),console.log("Loaded extensions:",[...t.ext.loadedExtensions.keys()]),t}function xt(e){const t=e.context.gl,r=j.create(e,X.Vertex,lt),s=j.create(e,X.Fragment,dt),i=J.create(e,r,s),o=new Float32Array([-.5,-.5,.5,.5,0,.5,-.5,0,1,0,.5,.5,0,.5,.5,-.5,.5,.5,0,.5]),h=new Int16Array([0,1,2,0,2,3]),u=k.create(e,Q.Array,Z.Static),d=k.create(e,Q.Element,Z.Static);u.setData(o),d.setData(h);const l=tt.create(e);l.setAttribute(0,u,2,t.FLOAT,5*Float32Array.BYTES_PER_ELEMENT,0),l.setAttribute(1,u,3,t.FLOAT,5*Float32Array.BYTES_PER_ELEMENT,2*Float32Array.BYTES_PER_ELEMENT),l.bindElementBuffer(d),i.use(),i.setUniformMatrix("u_world",q()),i.setUniformMatrix("u_mv",q()),t.enable(t.CULL_FACE),t.cullFace(t.BACK);function L(ht){t.clear(t.COLOR_BUFFER_BIT),i.use(),i.setUniform("u_time",ht/3e3);const st=t.canvas.width/t.canvas.height;i.setUniformMatrix("u_proj",ft(q(),-st,st,-1,1,-1,1)),l.bind(),t.drawElements(t.TRIANGLES,h.length,t.UNSIGNED_SHORT,0),l.unbind(),requestAnimationFrame(L)}L(0)}function Et(){const e=document.getElementById("cnv"),t=mt(e);xt(t)}Et();
