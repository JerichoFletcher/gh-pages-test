var st=e=>{throw TypeError(e)};var ot=(e,t,r)=>t.has(e)||st("Cannot "+r);var n=(e,t,r)=>(ot(e,t,"read from private field"),r?r.call(e):t.get(e)),c=(e,t,r)=>t.has(e)?st("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,r),a=(e,t,r,s)=>(ot(e,t,"write to private field"),s?s.call(e,r):t.set(e,r),r);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const l of o.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&s(l)}).observe(document,{childList:!0,subtree:!0});function r(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerPolicy&&(o.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?o.credentials="include":i.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(i){if(i.ep)return;i.ep=!0;const o=r(i);fetch(i.href,o)}})();var ht=`#version 100
precision mediump float;

attribute vec2 a_position;
attribute vec3 a_color;
varying vec3 v_color;

uniform mat4 u_world;
uniform mat4 u_mv;
uniform mat4 u_proj;

void main(){
  v_color = a_color;
  gl_Position = u_proj * u_mv * u_world * vec4(a_position, 0.0, 1.0);
}`,lt=`#version 100
precision mediump float;

varying vec3 v_color;
uniform float u_time;

void main(){
  vec3 rolledColor = mod(v_color + vec3(u_time), 1.0);
  gl_FragColor = vec4(rolledColor, 1.0);
}`;const j="OES_vertex_array_object";var T=(e=>(e[e.WebGL1=0]="WebGL1",e[e.WebGL2=1]="WebGL2",e))(T||{}),I,E;class dt{constructor(t){c(this,I);c(this,E);if(a(this,I,t),a(this,E,new Map),t.version===0){const r=t.gl.getExtension(j);r&&this.setExtension(j,{create:this.callWithContext(r,r.createVertexArrayOES),bind:this.callWithContext(r,r.bindVertexArrayOES),delete:this.callWithContext(r,r.deleteVertexArrayOES),isVAO:this.callWithContext(r,r.isVertexArrayOES)})}else this.setExtension(j,{create:this.callWithContext(t.gl,t.gl.createVertexArray),bind:this.callWithContext(t.gl,t.gl.bindVertexArray),delete:this.callWithContext(t.gl,t.gl.deleteVertexArray),isVAO:this.callWithContext(t.gl,t.gl.isVertexArray)})}callWithContext(t,r){return(...s)=>r.call(t,...s)}getExtension(t){if(!n(this,E).has(t))throw new Error(`Missing WebGL extension: ${t}`);return n(this,E).get(t)}setExtension(t,r){n(this,E).set(t,r)}get context(){return n(this,I)}get vertexArrayObject(){return this.getExtension(j)}}I=new WeakMap,E=new WeakMap;var N,U;const V=class V{constructor(t){c(this,N);c(this,U);a(this,N,t),a(this,U,new dt(t))}static latest(t){const r=t.getContext("webgl2");if(r)return new V({version:T.WebGL2,gl:r});const s=t.getContext("webgl");if(s)return new V({version:T.WebGL1,gl:s});throw new Error("Failed to create WebGL wrapper: WebGL not supported")}static ofVersion(t,r){let s;switch(r){case T.WebGL1:s=t.getContext("webgl");break;case T.WebGL2:s=t.getContext("webgl2");break}if(!s)throw new Error("Failed to create WebGL wrapper: Version not supported");return new V({version:r,gl:s})}get context(){return n(this,N)}get extension(){return n(this,U)}};N=new WeakMap,U=new WeakMap;let q=V;var L,$,F;const Y=class Y{constructor(t,r,s){c(this,L);c(this,$);c(this,F);a(this,L,t),a(this,$,r),a(this,F,s)}static validBeforeDisposed(t,r){return new Y(t,0,r)}static validAfterDisposed(t,r){return new Y(t,1,r)}executeWhenValid(t){switch(n(this,$)){case 0:if(n(this,L).isDisposed)throw new Error("Invalid state: Already disposed");return t();case 1:if(!n(this,L).isDisposed)throw new Error("Invalid state: Not disposed");return t()}}get value(){return this.executeWhenValid(()=>n(this,F))}set value(t){this.executeWhenValid(()=>a(this,F,t))}};L=new WeakMap,$=new WeakMap,F=new WeakMap;let D=Y;var K=(e=>(e[e.Vertex=0]="Vertex",e[e.Fragment=1]="Fragment",e))(K||{}),w,W,B,O;const tt=class tt{constructor(t,r,s){c(this,w);c(this,W);c(this,B);c(this,O);a(this,W,t),a(this,B,r);const i=t.context.gl,o=i.createShader(r===0?i.VERTEX_SHADER:i.FRAGMENT_SHADER);if(!o){const l=i.getError();throw new Error(`Failed to create shader (error code ${l})`)}if(i.shaderSource(o,s),i.compileShader(o),!i.getShaderParameter(o,i.COMPILE_STATUS)){const l=i.getError(),g=i.getShaderInfoLog(o);throw i.deleteShader(o),new Error(`Failed to compile shader (error code: ${l}): ${g}`)}a(this,O,D.validBeforeDisposed(this,o)),a(this,w,!1)}static create(t,r,s){return new tt(t,r,s)}get contextWrapper(){return n(this,W)}get type(){return n(this,B)}get shader(){return n(this,O).value}get isDisposed(){return n(this,w)}dispose(){n(this,w)||(n(this,W).context.gl.deleteShader(n(this,O).value),a(this,w,!0))}};w=new WeakMap,W=new WeakMap,B=new WeakMap,O=new WeakMap;let z=tt;var p,f,m,R,C,b,M;const et=class et{constructor(t,r,s){c(this,p);c(this,f);c(this,m);c(this,R);c(this,C);c(this,b);c(this,M);a(this,f,t);const i=t.context.gl,o=i.createProgram();if(!o){const d=i.getError();throw new Error(`Failed to create program (error code ${d})`)}if(i.attachShader(o,r.shader),i.attachShader(o,s.shader),i.linkProgram(o),!i.getProgramParameter(o,i.LINK_STATUS)){const d=i.getError(),h=i.getProgramInfoLog(o);throw i.deleteProgram(o),new Error(`Failed to link program (error code: ${d}): ${h}`)}a(this,b,new Map),a(this,M,new Map);const l=i.getProgramParameter(o,i.ACTIVE_UNIFORMS);for(let d=0;d<l;d++){const h=i.getActiveUniform(o,d),S=i.getUniformLocation(o,h.name);n(this,b).set(h.name,{name:h.name,size:h.size,type:h.type,location:S})}const g=i.getProgramParameter(o,i.ACTIVE_ATTRIBUTES);for(let d=0;d<g;d++){const h=i.getActiveAttrib(o,d),S=i.getAttribLocation(o,h.name);n(this,M).set(h.name,{name:h.name,size:h.size,type:h.type,location:S})}a(this,m,D.validBeforeDisposed(this,o)),a(this,R,r),a(this,C,s),a(this,p,!1)}static create(t,r,s){return new et(t,r,s)}use(){n(this,f).context.gl.useProgram(n(this,m).value)}setUniform(t,r){const s=n(this,f).context.gl,i=n(this,b).get(t);if(!i)throw new Error(`Unknown uniform: ${t}`);if(typeof r=="number")s.uniform1f(i.location,r);else if(Array.isArray(r)||r instanceof Float32Array)switch(r.length){case 2:s.uniform2fv(i.location,r);break;case 3:s.uniform3fv(i.location,r);break;case 4:s.uniform4fv(i.location,r);break;default:throw new Error(`Unsupported uniform array size: ${r.length}`)}}setUniformMatrix(t,r){const s=n(this,f).context.gl,i=n(this,b).get(t);if(!i)throw new Error(`Unknown uniform: ${t}`);switch(r.length){case 4:s.uniformMatrix2fv(i.location,!1,r);break;case 9:s.uniformMatrix3fv(i.location,!1,r);break;case 16:s.uniformMatrix4fv(i.location,!1,r);break;default:throw new Error(`Unsupported uniform matrix size: ${r.length}`)}}get contextWrapper(){return n(this,f)}get program(){return n(this,m).value}get vertexShader(){return n(this,R)}get fragmentShader(){return n(this,C)}get uniforms(){return n(this,b)}get attributes(){return n(this,M)}get isDisposed(){return n(this,p)}dispose(){n(this,p)||(n(this,f).context.gl.detachShader(n(this,m),n(this,R).shader),n(this,f).context.gl.detachShader(n(this,m),n(this,C).shader),n(this,f).context.gl.deleteProgram(n(this,m)),a(this,p,!0))}};p=new WeakMap,f=new WeakMap,m=new WeakMap,R=new WeakMap,C=new WeakMap,b=new WeakMap,M=new WeakMap;let X=et;var J=(e=>(e[e.Array=0]="Array",e[e.Element=1]="Element",e))(J||{}),Q=(e=>(e[e.Static=0]="Static",e[e.Dynamic=1]="Dynamic",e[e.Stream=2]="Stream",e))(Q||{}),A,u,P,H,v;const rt=class rt{constructor(t,r,s){c(this,A);c(this,u);c(this,P);c(this,H);c(this,v);a(this,u,t),a(this,P,r),a(this,H,s);const i=t.context.gl.createBuffer();if(!i){const o=t.context.gl.getError();throw new Error(`Failed to create buffer object (error code: ${o})`)}a(this,v,D.validBeforeDisposed(this,i)),a(this,A,!1)}static create(t,r,s){return new rt(t,r,s)}get target(){switch(n(this,P)){case 0:return n(this,u).context.gl.ARRAY_BUFFER;case 1:return n(this,u).context.gl.ELEMENT_ARRAY_BUFFER}}get usage(){switch(n(this,H)){case 0:return n(this,u).context.gl.STATIC_DRAW;case 1:return n(this,u).context.gl.DYNAMIC_DRAW;case 2:return n(this,u).context.gl.STREAM_DRAW}}bind(){const t=n(this,v).value;n(this,u).context.gl.bindBuffer(this.target,t)}unbind(){n(this,u).context.gl.bindBuffer(this.target,null)}setData(t){this.bind(),n(this,u).context.gl.bufferData(this.target,t,this.usage),this.unbind()}get contextWrapper(){return n(this,u)}get type(){return n(this,P)}get buffer(){return n(this,v).value}get isDisposed(){return n(this,A)}dispose(){n(this,A)||(n(this,u).context.gl.deleteBuffer(n(this,v)),a(this,A,!0))}};A=new WeakMap,u=new WeakMap,P=new WeakMap,H=new WeakMap,v=new WeakMap;let G=rt;var y,x,_;const it=class it{constructor(t){c(this,y);c(this,x);c(this,_);a(this,x,t);const r=t.extension.vertexArrayObject.create();if(!r){const s=t.context.gl.getError();throw new Error(`Failed to create VAO (error code ${s})`)}a(this,_,D.validBeforeDisposed(this,r)),a(this,y,!1)}static create(t){return new it(t)}bind(){n(this,x).extension.vertexArrayObject.bind(n(this,_).value)}unbind(){n(this,x).extension.vertexArrayObject.bind(null)}setAttribute(t,r,s,i,o,l){this.bind(),r.bind();const g=n(this,x).context.gl;g.enableVertexAttribArray(t),g.vertexAttribPointer(t,s,i,!1,o,l),r.unbind(),this.unbind()}bindElementBuffer(t){this.bind(),t.bind(),this.unbind()}get contextWrapper(){return n(this,x)}get vao(){return n(this,_).value}get isDisposed(){return n(this,y)}dispose(){n(this,y)||(n(this,x).extension.vertexArrayObject.delete(n(this,_).value),a(this,y,!0))}};y=new WeakMap,x=new WeakMap,_=new WeakMap;let Z=it;var at=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});function k(){var e=new at(16);return at!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function ut(e,t,r,s,i,o,l){var g=1/(t-r),d=1/(s-i),h=1/(o-l);return e[0]=-2*g,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*d,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*h,e[11]=0,e[12]=(t+r)*g,e[13]=(i+s)*d,e[14]=(l+o)*h,e[15]=1,e}var gt=ut;function ft(e){const t=q.latest(e),r=t.context.gl,s=()=>{let i=!1;const o=e.clientWidth,l=e.clientHeight;(e.width!==o||e.height!==l)&&(e.width=o,e.height=l,i=!0),i&&r.viewport(0,0,e.width,e.height)};return window.addEventListener("resize",s),s(),console.log("Loaded WebGL version:",r.getParameter(r.VERSION)),t}function mt(e){const t=e.context.gl,r=z.create(e,K.Vertex,ht),s=z.create(e,K.Fragment,lt),i=X.create(e,r,s),o=new Float32Array([-.5,-.5,.5,.5,0,.5,-.5,0,1,0,.5,.5,0,.5,.5,-.5,.5,.5,0,.5]),l=new Int16Array([0,1,2,0,2,3]),g=G.create(e,J.Array,Q.Static),d=G.create(e,J.Element,Q.Static);g.setData(o),d.setData(l);const h=Z.create(e);h.setAttribute(0,g,2,t.FLOAT,5*Float32Array.BYTES_PER_ELEMENT,0),h.setAttribute(1,g,3,t.FLOAT,5*Float32Array.BYTES_PER_ELEMENT,2*Float32Array.BYTES_PER_ELEMENT),h.bindElementBuffer(d),i.use(),i.setUniformMatrix("u_world",k()),i.setUniformMatrix("u_mv",k()),t.enable(t.CULL_FACE),t.cullFace(t.BACK);function S(ct){t.clear(t.COLOR_BUFFER_BIT),i.use(),i.setUniform("u_time",ct/3e3);const nt=t.canvas.width/t.canvas.height;i.setUniformMatrix("u_proj",gt(k(),-nt,nt,-1,1,-1,1)),h.bind(),t.drawElements(t.TRIANGLES,l.length,t.UNSIGNED_SHORT,0),h.unbind(),requestAnimationFrame(S)}S(0)}function xt(){const e=document.getElementById("cnv"),t=ft(e);mt(t)}xt();
