var nt=i=>{throw TypeError(i)};var ot=(i,t,e)=>t.has(i)||nt("Cannot "+e);var r=(i,t,e)=>(ot(i,t,"read from private field"),e?e.call(i):t.get(i)),c=(i,t,e)=>t.has(i)?nt("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(i):t.set(i,e),a=(i,t,e,n)=>(ot(i,t,"write to private field"),n?n.call(i,e):t.set(i,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const l of o.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&n(l)}).observe(document,{childList:!0,subtree:!0});function e(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function n(s){if(s.ep)return;s.ep=!0;const o=e(s);fetch(s.href,o)}})();const G="OES_vertex_array_object";var M=(i=>(i[i.WebGL1=0]="WebGL1",i[i.WebGL2=1]="WebGL2",i))(M||{}),_,m;class ht{constructor(t){c(this,_);c(this,m);if(a(this,_,t),a(this,m,new Map),t.version===0){const e=t.gl.getExtension(G);e&&this.setExtension(G,{create:this.callWithContext(e,e.createVertexArrayOES),bind:this.callWithContext(e,e.bindVertexArrayOES),delete:this.callWithContext(e,e.deleteVertexArrayOES),isVAO:this.callWithContext(e,e.isVertexArrayOES)})}else this.setExtension(G,{create:this.callWithContext(t.gl,t.gl.createVertexArray),bind:this.callWithContext(t.gl,t.gl.bindVertexArray),delete:this.callWithContext(t.gl,t.gl.deleteVertexArray),isVAO:this.callWithContext(t.gl,t.gl.isVertexArray)})}callWithContext(t,e){return(...n)=>e.call(t,...n)}getExtension(t){if(!r(this,m).has(t))throw new Error(`Missing WebGL extension: ${t}`);return r(this,m).get(t)}setExtension(t,e){r(this,m).set(t,e)}get context(){return r(this,_)}get vertexArrayObject(){return this.getExtension(G)}}_=new WeakMap,m=new WeakMap;var $,B;const N=class N{constructor(t){c(this,$);c(this,B);a(this,$,t),a(this,B,new ht(t))}static latest(t){const e=t.getContext("webgl2");if(e)return new N({version:M.WebGL2,gl:e});const n=t.getContext("webgl");if(n)return new N({version:M.WebGL1,gl:n});throw new Error("Failed to create WebGL wrapper: WebGL not supported")}static ofVersion(t,e){let n;switch(e){case M.WebGL1:n=t.getContext("webgl");break;case M.WebGL2:n=t.getContext("webgl2");break}if(!n)throw new Error("Failed to create WebGL wrapper: Version not supported");return new N({version:e,gl:n})}get context(){return r(this,$)}get extension(){return r(this,B)}};$=new WeakMap,B=new WeakMap;let q=N;var F,U,W;const Y=class Y{constructor(t,e,n){c(this,F);c(this,U);c(this,W);a(this,F,t),a(this,U,e),a(this,W,n)}static validBeforeDisposed(t,e){return new Y(t,0,e)}static validAfterDisposed(t,e){return new Y(t,1,e)}executeWhenValid(t){switch(r(this,U)){case 0:if(r(this,F).isDisposed)throw new Error("Invalid state: Already disposed");return t();case 1:if(!r(this,F).isDisposed)throw new Error("Invalid state: Not disposed");return t()}}get value(){return this.executeWhenValid(()=>r(this,W))}set value(t){this.executeWhenValid(()=>a(this,W,t))}};F=new WeakMap,U=new WeakMap,W=new WeakMap;let C=Y;var K=(i=>(i[i.Vertex=0]="Vertex",i[i.Fragment=1]="Fragment",i))(K||{}),E,O,H,R;const tt=class tt{constructor(t,e,n){c(this,E);c(this,O);c(this,H);c(this,R);a(this,O,t),a(this,H,e);const s=t.context.gl,o=s.createShader(e===0?s.VERTEX_SHADER:s.FRAGMENT_SHADER);if(!o){const l=s.getError();throw new Error(`Failed to create shader (error code ${l})`)}if(s.shaderSource(o,n),s.compileShader(o),!s.getShaderParameter(o,s.COMPILE_STATUS)){const l=s.getError(),b=s.getShaderInfoLog(o);throw s.deleteShader(o),new Error(`Failed to compile shader (error code: ${l}): ${b}`)}a(this,R,C.validBeforeDisposed(this,o)),a(this,E,!1)}static create(t,e,n){return new tt(t,e,n)}get contextWrapper(){return r(this,O)}get type(){return r(this,H)}get shader(){return r(this,R).value}get isDisposed(){return r(this,E)}dispose(){r(this,E)||(r(this,O).context.gl.deleteShader(r(this,R).value),a(this,E,!0))}};E=new WeakMap,O=new WeakMap,H=new WeakMap,R=new WeakMap;let j=tt;var w,g,f,P,D,A,T;const et=class et{constructor(t,e,n){c(this,w);c(this,g);c(this,f);c(this,P);c(this,D);c(this,A);c(this,T);a(this,g,t);const s=t.context.gl,o=s.createProgram();if(!o){const d=s.getError();throw new Error(`Failed to create program (error code ${d})`)}if(s.attachShader(o,e.shader),s.attachShader(o,n.shader),s.linkProgram(o),!s.getProgramParameter(o,s.LINK_STATUS)){const d=s.getError(),h=s.getProgramInfoLog(o);throw s.deleteProgram(o),new Error(`Failed to link program (error code: ${d}): ${h}`)}a(this,A,new Map),a(this,T,new Map);const l=s.getProgramParameter(o,s.ACTIVE_UNIFORMS);for(let d=0;d<l;d++){const h=s.getActiveUniform(o,d),L=s.getUniformLocation(o,h.name);r(this,A).set(h.name,{name:h.name,size:h.size,type:h.type,location:L})}const b=s.getProgramParameter(o,s.ACTIVE_ATTRIBUTES);for(let d=0;d<b;d++){const h=s.getActiveAttrib(o,d),L=s.getAttribLocation(o,h.name);r(this,T).set(h.name,{name:h.name,size:h.size,type:h.type,location:L})}a(this,f,C.validBeforeDisposed(this,o)),a(this,P,e),a(this,D,n),a(this,w,!1)}static create(t,e,n){return new et(t,e,n)}use(){r(this,g).context.gl.useProgram(r(this,f).value)}setUniform(t,e){const n=r(this,g).context.gl,s=r(this,A).get(t);if(!s)throw new Error(`Unknown uniform: ${t}`);if(typeof e=="number")n.uniform1f(s.location,e);else if(Array.isArray(e))switch(e.length){case 2:n.uniform2fv(s.location,e);break;case 3:n.uniform3fv(s.location,e);break;case 4:n.uniform4fv(s.location,e);break;default:throw new Error(`Unsupported uniform array size: ${e.length}`)}else if(e instanceof Float32Array)switch(e.length){case 4:n.uniformMatrix2fv(s.location,!1,e);break;case 9:n.uniformMatrix3fv(s.location,!1,e);break;case 16:n.uniformMatrix4fv(s.location,!1,e);break;default:throw new Error(`Unsupported uniform matrix size: ${e.length}`)}}get contextWrapper(){return r(this,g)}get program(){return r(this,f).value}get vertexShader(){return r(this,P)}get fragmentShader(){return r(this,D)}get uniforms(){return r(this,A)}get attributes(){return r(this,T)}get isDisposed(){return r(this,w)}dispose(){r(this,w)||(r(this,g).context.gl.detachShader(r(this,f),r(this,P).shader),r(this,g).context.gl.detachShader(r(this,f),r(this,D).shader),r(this,g).context.gl.deleteProgram(r(this,f)),a(this,w,!0))}};w=new WeakMap,g=new WeakMap,f=new WeakMap,P=new WeakMap,D=new WeakMap,A=new WeakMap,T=new WeakMap;let X=et;var J=(i=>(i[i.Array=0]="Array",i[i.Element=1]="Element",i))(J||{}),Q=(i=>(i[i.Static=0]="Static",i[i.Dynamic=1]="Dynamic",i[i.Stream=2]="Stream",i))(Q||{}),p,u,V,z,y;const rt=class rt{constructor(t,e,n){c(this,p);c(this,u);c(this,V);c(this,z);c(this,y);a(this,u,t),a(this,V,e),a(this,z,n);const s=t.context.gl.createBuffer();if(!s){const o=t.context.gl.getError();throw new Error(`Failed to create buffer object (error code: ${o})`)}a(this,y,C.validBeforeDisposed(this,s)),a(this,p,!1)}static create(t,e,n){return new rt(t,e,n)}get target(){switch(r(this,V)){case 0:return r(this,u).context.gl.ARRAY_BUFFER;case 1:return r(this,u).context.gl.ELEMENT_ARRAY_BUFFER}}get usage(){switch(r(this,z)){case 0:return r(this,u).context.gl.STATIC_DRAW;case 1:return r(this,u).context.gl.DYNAMIC_DRAW;case 2:return r(this,u).context.gl.STREAM_DRAW}}bind(){const t=r(this,y).value;r(this,u).context.gl.bindBuffer(this.target,t)}unbind(){r(this,u).context.gl.bindBuffer(this.target,null)}setData(t){this.bind(),r(this,u).context.gl.bufferData(this.target,t,this.usage),this.unbind()}get contextWrapper(){return r(this,u)}get type(){return r(this,V)}get buffer(){return r(this,y).value}get isDisposed(){return r(this,p)}dispose(){r(this,p)||(r(this,u).context.gl.deleteBuffer(r(this,y)),a(this,p,!0))}};p=new WeakMap,u=new WeakMap,V=new WeakMap,z=new WeakMap,y=new WeakMap;let k=rt;var v,x,S;const st=class st{constructor(t){c(this,v);c(this,x);c(this,S);a(this,x,t);const e=t.extension.vertexArrayObject.create();if(!e){const n=t.context.gl.getError();throw new Error(`Failed to create VAO (error code ${n})`)}a(this,S,C.validBeforeDisposed(this,e)),a(this,v,!1)}static create(t){return new st(t)}bind(){r(this,x).extension.vertexArrayObject.bind(r(this,S).value)}unbind(){r(this,x).extension.vertexArrayObject.bind(null)}setAttribute(t,e,n,s,o,l){this.bind(),e.bind();const b=r(this,x).context.gl;b.enableVertexAttribArray(t),b.vertexAttribPointer(t,n,s,!1,o,l),e.unbind(),this.unbind()}bindElementBuffer(t){this.bind(),t.bind(),this.unbind()}get contextWrapper(){return r(this,x)}get vao(){return r(this,S).value}get isDisposed(){return r(this,v)}dispose(){r(this,v)||(r(this,x).extension.vertexArrayObject.delete(r(this,S).value),a(this,v,!0))}};v=new WeakMap,x=new WeakMap,S=new WeakMap;let Z=st;async function at(i){return await(await fetch(i)).text()}function lt(i){const t=()=>{i.width=window.innerWidth,i.height=window.innerHeight};document.addEventListener("resize",t),t();const e=q.latest(i),n=e.context.gl;return console.log("Loaded WebGL version:",n.getParameter(n.VERSION)),e}async function dt(i){const t=i.context.gl,e=await at("/shaders/test.vert.glsl"),n=await at("/shaders/test.frag.glsl"),s=j.create(i,K.Vertex,e),o=j.create(i,K.Fragment,n),l=X.create(i,s,o),b=new Float32Array([-.5,-.5,.5,.5,0,.5,-.5,0,1,0,.5,.5,0,.5,.5,-.5,.5,.5,0,.5]),d=new Int16Array([0,1,2,0,2,3]),h=k.create(i,J.Array,Q.Static),L=k.create(i,J.Element,Q.Static);h.setData(b),L.setData(d);const I=Z.create(i);I.setAttribute(0,h,2,t.FLOAT,5*Float32Array.BYTES_PER_ELEMENT,0),I.setAttribute(1,h,3,t.FLOAT,5*Float32Array.BYTES_PER_ELEMENT,2*Float32Array.BYTES_PER_ELEMENT),I.bindElementBuffer(L);function it(ct){t.clear(t.COLOR_BUFFER_BIT),l.use(),l.setUniform("u_time",ct/3e3),I.bind(),t.drawElements(t.TRIANGLES,d.length,t.UNSIGNED_SHORT,0),I.unbind(),requestAnimationFrame(it)}it(0)}async function ut(){const i=document.getElementById("cnv"),t=lt(i);await dt(t)}ut();
